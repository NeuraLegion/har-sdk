import { Sampler, OpenAPISchema } from './Sampler';
import RandExp from 'randexp';

export class StringSampler implements Sampler {
  private readonly stringFormats = {
    'email': () => 'jon.snow@targaryen.com',
    'idn-email': () => 'джон.сноу@таргариен.укр',
    'password': (min: number, max: number) =>
      this.adjustLength('p@$$w0rd', min, max),
    'date-time': () => '2021-12-31T23:34:00Z',
    'date': () => '2021-12-31',
    'time': () => '23:34:00Z',
    'duration': () => 'P3D',
    'ipv4': () => '208.67.222.222',
    'ipv6': () => '0000:0000:0000:0000:0000:ffff:d043:dcdc',
    'hostname': () => 'brokencrystals.com',
    'idn-hostname': () => 'сломанные-кристаллы.бел',
    'iri': () =>
      'https://be.wikipedia.org/wiki/%D0%9A%D1%80%D1%8B%D1%88%D1%82%D0%B0%D0%BB%D1%96',
    'iri-reference': () =>
      '/wiki/%D0%9A%D1%80%D1%8B%D1%88%D1%82%D0%B0%D0%BB%D1%96',
    'uri': () => 'https://github.com/NeuraLegion/brokencrystals',
    'uri-reference': () => '../brokencrystals',
    'uri-template': () => 'https://brokencrystals.com/api/file/{provider}',
    'byte': () => 'ZHVtbXkgYmluYXJ5IHNhbXBsZQA=',
    'binary': () => '\x01\x02\x03\x04\x05',
    'base64': () => 'ZHVtbXkgYmluYXJ5IHNhbXBsZQA=',
    'uuid': () => 'fbdf5a53-161e-4460-98ad-0e39408d8689',
    'json-pointer': () => '/json/pointer',
    'relative-json-pointer': () => '1/relative/json/pointer',
    'regex': () => '/regex/',
    'pattern': (
      min: number,
      max: number,
      { pattern }: { pattern: string | RegExp }
    ) => this.patternSample(pattern, min, max),
    'default': (min: number, max: number) =>
      this.adjustLength('lorem', min, max)
  };

  public sample(schema: OpenAPISchema): any {
    const format = schema.pattern ? 'pattern' : schema.format || 'default';
    const sampler = this.stringFormats[format] || this.stringFormats['default'];

    const { minLength: min, maxLength: max } = schema;

    return this.checkLength(sampler(min || 0, max, schema), format, min, max);
  }

  private patternSample(
    pattern: string | RegExp,
    min?: number,
    max?: number
  ): string {
    const randExp = new RandExp(pattern);

    if (min) {
      return this.sampleMinLength(randExp, min, max);
    }

    randExp.max = max ?? randExp.max;
    randExp.randInt = (a, b) => Math.floor((a + b) / 2);

    const result = randExp.gen();

    return !!max && result.length > max && this.hasInfiniteQuantifier(pattern)
      ? this.sampleInfiniteQuantifier(randExp, max)
      : result;
  }

  private hasInfiniteQuantifier(pattern: string | RegExp) {
    const pat = pattern.toString();

    return ['+', '*', ',}'].some((q) => pat.includes(q));
  }

  private sampleInfiniteQuantifier(randExp: RandExp, max: number): string {

    randExp.randInt = (a, b) => Math.floor((a + b) / 2);

    for (let i = 1, lmax = max; lmax > 0; lmax = Math.floor(max / ++i)) {
      randExp.max = lmax;

      const result = randExp.gen();

      if (result.length <= max) {
        return result;
      }
    }

    return '';
  }

  private sampleMinLength(randExp: RandExp, min: number, max: number) {
    // ADHOC: make a probe for regex using min quantifier value
    // e.g. ^[a]+[b]+$ expect 'ab', ^[a-z]*$ expect ''

    randExp.max = 0;
    randExp.randInt = (a, _) => a;

    const result = randExp.gen();

    if (result.length >= min) {
      return result;
    }

    // ADHOC: fallback for failed min quantifier probe with doubled min length

    randExp.max = 2 * min;
    randExp.randInt = (a, b) => Math.floor((a + b) / 2);

    return this.adjustMaxLength(randExp.gen(), max);
  }

  private checkLength(
    value: string,
    format: string,
    min: number,
    max: number
  ): string {
    if ((min && value.length < min) || (max && value.length > max)) {
      const pairs = [
        { key: 'minLength', value: min },
        { key: 'maxLength', value: max },
        { key: 'format', value: format }
      ];

      const boundariesStr = pairs
        .filter((p) => p.value !== undefined)
        .map((p) => `${p.key}=${p.value}`)
        .join(', ');

      throw new Error(
        `Sample string cannot be generated by boundaries: ${boundariesStr}`
      );
    }

    return value;
  }

  private adjustLength(sample: string, min: number, max: number): string {
    const minLength = min ? min : 0;
    const maxLength = max ? max : sample.length;

    return minLength > sample.length
      ? sample
          .repeat(Math.trunc(minLength / sample.length) + 1)
          .substring(0, minLength)
      : sample.substr(
          0,
          Math.min(Math.max(sample.length, minLength), maxLength)
        );
  }

  private adjustMaxLength(sample: string, max?: number): string {
    return max && sample.length >= max ? sample.substring(0, max) : sample;
  }
}
