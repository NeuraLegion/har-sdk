import { OpenAPISchema, Sampler } from './Sampler';

type Boundary = {
  readonly value: number;
  readonly exclusive: boolean;
};

type Options = {
  schema: OpenAPISchema;
  minimum?: Boundary;
  maximum?: Boundary;
};

export class NumberSampler implements Sampler {
  private readonly EPS = 0.001;

  public sample(schema: OpenAPISchema): number {
    const type = schema.type ? schema.type : 'number';
    const integer = type === 'integer';

    const minimum = this.getMinimum(schema);
    const maximum = this.getMaximum(schema);

    let res;
    let usingMaximum = false;

    if (minimum) {
      res = this.sampleUsingMinimum(minimum, integer);
    } else if (maximum) {
      usingMaximum = true;
      res = this.sampleUsingMaximum(maximum, integer);
    }

    if (schema.multipleOf) {
      res = this.roundUp(res ?? schema.multipleOf, schema.multipleOf);
      res = usingMaximum ? res - schema.multipleOf : res;
    }

    return this.ensureBoundaries(res ?? 42, { minimum, maximum, schema });
  }

  private sampleUsingMinimum(boundary: Boundary, integer: boolean): number {
    let schemaMinimum = boundary.value;
    let exclusiveMinimum = boundary.exclusive;

    if (integer && !Number.isInteger(schemaMinimum)) {
      schemaMinimum = Math.ceil(schemaMinimum);
      exclusiveMinimum = false;
    }

    return exclusiveMinimum
      ? schemaMinimum + (integer ? 1 : this.EPS)
      : schemaMinimum;
  }

  private sampleUsingMaximum(boundary: Boundary, integer: boolean): number {
    let schemaMaximum = boundary.value;
    let exclusiveMaximum = boundary.exclusive;

    if (integer && !Number.isInteger(schemaMaximum)) {
      schemaMaximum = Math.floor(schemaMaximum);
      exclusiveMaximum = false;
    }

    return exclusiveMaximum
      ? schemaMaximum - (integer ? 1 : this.EPS)
      : schemaMaximum;
  }

  private roundUp(value: number, multipleOf: number): number {
    if (!multipleOf || !value) {
      return 0;
    }

    return Math.ceil(value / multipleOf) * multipleOf;
  }

  private ensureBoundaries(value: number, options: Options): number {
    const { minimum, maximum, schema } = options;

    let valid = true;

    if (minimum) {
      valid = this.isValidMinimum(minimum, value);
    }

    if (maximum) {
      valid = this.isValidMaximum(maximum, value);
    }

    if (
      valid &&
      schema.multipleOf &&
      !Number.isInteger(value / schema.multipleOf)
    ) {
      valid = false;
    }

    if (!valid) {
      throw new Error(
        `Sample numeric cannot be generated by boundaries: ${this.formatConditions(
          options
        )}`
      );
    }

    return value;
  }

  private isValidMinimum(minimum: Boundary, value: number): boolean {
    return minimum.exclusive ? value > minimum.value : value >= minimum.value;
  }

  private isValidMaximum(maximum: Boundary, value: number): boolean {
    return maximum.exclusive ? value < maximum.value : value <= maximum.value;
  }

  private formatConditions({ minimum, maximum, schema }: Options): string {
    let res = '';

    if (minimum) {
      res += `${minimum.value} ${minimum.exclusive ? '<' : '<='} `;
    }

    res += 'x';

    if (maximum) {
      res += ` ${maximum.exclusive ? '<' : '<='} ${maximum.value}`;
    }

    if ('multipleOf' in schema) {
      res += `, multipleOf: ${schema.multipleOf}`;
    }

    return res;
  }

  private getMinimum(schema: OpenAPISchema) {
    let value = schema.minimum ?? undefined;
    let exclusive = !!schema.exclusiveMinimum;

    if (typeof schema.exclusiveMinimum === 'number') {
      value = schema.exclusiveMinimum;
      exclusive = true;
    }

    return value !== undefined
      ? {
          value,
          exclusive
        }
      : undefined;
  }

  private getMaximum(schema: OpenAPISchema) {
    let value = schema.maximum ?? undefined;
    let exclusive = !!schema.exclusiveMaximum;

    if (typeof schema.exclusiveMaximum === 'number') {
      value = schema.exclusiveMaximum;
      exclusive = true;
    }

    return value !== undefined
      ? {
          value,
          exclusive
        }
      : undefined;
  }
}
